import socket
import random
import string
import pickle
import sys
from _thread import *
import json
import time

def generate_random_str(len =5):
    return (''.join(random.choices(string.ascii_letters, k=len)))


class Peer:
    def __init__(self,ip,port):
        self.ip = ip
        self.port = port
        self.listening_socket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
        self.listening_socket.bind((ip,int(port)))
        self.peers = []
        self.selected_peers = {}
        self.message_list = {}
        self.selected_peer_ports = {}



    def register(self):
        seeds_list = [details.split() for details in open('config.txt',"r").readlines()]
        n = len(seeds_list)
        seeds_to_connect = random.sample(seeds_list,n//2+1)
        seed_sockets = []
        for ip,port in seeds_to_connect:
            register_socket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
            register_socket.connect((ip,int(port)))
            register_socket.send(f"Reg {self.ip} {self.port}".encode('utf-8'))
            
            if(register_socket.recv(4096).decode('utf-8')!='OK'):
                raise Exception(f"Didnt get response from seed with ip {ip} and port {port}")
            
            register_socket.send("PeerRequest".encode('utf-8'))
            server_peer_list = pickle.loads(register_socket.recv(4096))
            server_peer_list = [i for i in server_peer_list if i !=f"{self.ip} {self.port}" ]
            print(f"Peer node {self.ip}:{self.port} connected to server {ip}:{port} and received Peers list ",server_peer_list)
            with open("output.txt",'a') as f:
                f.write(f"Peer node {self.ip}:{self.port} connected to server {ip}:{port} and received Peers list "+ repr(server_peer_list)+"\n")

            self.peers.extend([i for i in server_peer_list if i not in self.peers ]) #Union of received peer lists
            seed_sockets.append(register_socket) #list of connected seed sockets
            n_peers = min(4,len(self.peers))
            selected_peers = random.sample(self.peers,n_peers)
            for peer in selected_peers:
                conn_socket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
                
                peer_ip,peer_port = peer.split()
                conn_socket.connect((peer_ip,int(peer_port)))
                self.selected_peers[peer_port] = conn_socket   
                self.selected_peer_ports[conn_socket] = peer_port

    def gossip(self):
        for _ in range(10):
            self.send_gossip_msg()
            time.sleep(5)

    def send_gossip_msg(self,msg = None):
        if msg is None:

            msg ={}
            msg["content"] =  generate_random_str()
            msg["went_through"] = {}
            msg['Generator'] = self.port 
            msg['timestamp'] = time.time()
        msg['sender'] = self.port
        msg["went_through"][self.port] = True
        for peer in self.selected_peers:
            if(peer not in msg['went_through']):
                self.selected_peers[peer].send(json.dumps(msg,sort_keys=True).encode())

    def handle_other_peer(self,peer_socket):
        while True:
            msg = peer_socket.recv(4096)
            if (msg.decode()[0:5]== 'live'):
                pass
            else :
                try:
                    msg = json.loads(msg.decode())

                    if(msg['content'] not in self.message_list):
                        self.message_list[msg['content']] = True
                        print(f"Peer 127.0.0.1 {self.port} received msg {msg['content']} from Peer 127.0.0.1 {msg['sender']} generated by 127.0.0.1 {msg['Generator']} at timestamp {msg['timestamp']}")
                        with open('output.txt','a') as f:
                            f.write(f"Peer 127.0.0.1 {self.port} received msg {msg['content']} from Peer 127.0.0.1 {msg['sender']} generated by {msg['Generator']} at timestamp {msg['timestamp']} \n")
                        self.send_gossip_msg(msg)
                    else:
                        pass
                        
                except Exception as e:
                    print(e)
                    exit()
                

        
               
               
        
                                    
            
            
if __name__ == "__main__":
    ip,port = sys.argv[1],sys.argv[2]
    peer = Peer(ip,port)
    peer.register()
    
    start_new_thread(peer.gossip,())
    peer.listening_socket.listen()

    while True:
        peer_socket, addr = peer.listening_socket.accept()
        start_new_thread(peer.handle_other_peer,(peer_socket,))


        
        

        



        
